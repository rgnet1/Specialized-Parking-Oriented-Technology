/*
 * Copyright (c) 2015-2017, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  ======== empty.c ========
 */

/* For usleep() */
#include <unistd.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>

/* Driver Header files */
#include <ti/drivers/GPIO.h>
// #include <ti/drivers/I2C.h>
// #include <ti/drivers/SDSPI.h>
#include <ti/drivers/SPI.h>
#include <ti/drivers/UART.h>
// #include <ti/drivers/Watchdog.h>
#include <ti/drivers/Timer.h>
#include <ti/drivers/net/wifi/simplelink.h>

/* Board Header file */
#include "Board.h"
#include "uart_term.h"

/*
 *  ======== mainThread ========
 */

#define RGB_ON 0
#define RGB_OFF 1
#define THRESHOLD 5000
#define WIFI_SSID "Mothboy's Iphone"
#define WIFI_KEY "mothboy15"

typedef struct parkingControlBlock_t
{
    /* Status Variables */
    uint32_t        Status;             /* This bit-wise status variable shows the state of the NWP */
    uint32_t        Role;               /* This field keeps the device's role (STA, P2P or AP) */
    uint32_t        Exit;               /* This flag lets the application to exit */
    uint32_t        PingAttempts;       /* Sets the number of Ping attempts to send */
    /* Data & Network entry Union */
    gDataBuffer_t     gDataBuffer;
    /* P2P mode CB */
    p2p_CB            P2P_CB;
    /* STA/AP mode CB */
    connection_CB    CON_CB;
    /* Cmd Prompt buffer */
    uint8_t         CmdBuffer[CMD_BUFFER_LEN];
    /* WoWLAN semaphore */
    sem_t            WowlanSleepSem;
}parkingControlBlock;

/* Callback used for toggling the LED. */
void timerCallback(Timer_Handle myHandle);
void distCallback(Timer_Handle myHandle);
void RGBTest(Timer_Handle myHandle);
void inputTest(Timer_Handle myHandle);
void BT_Test(Timer_Handle myHandle);
void StopWatch_Test(Timer_Handle myHandle);
void TRIG_PULSE(Timer_Handle myHandle);

/* Other functions for sensor */
void setPulse(useconds_t time);
void DoNothing(void);
int GetDistance(uint32_t distime);
void exPulse(useconds_t time);



int ZeroHour = 0;
uint_fast8_t Echo_Echo = 0;
uint_fast8_t Echo_1 = 0;
uint32_t DistTime = 0;
uint32_t Echo_Beg = 0;
uint32_t Echo_End = 0;
int ans = 0;
int BTcount = 0;
int break_it = 0;
int i = 0;

/* Initialize timer handlers and parameters */
Timer_Handle sens_timer;
Timer_Params sens_params;

parkingControlBlock     parking_CB;

/* Event Handler Functions */
/*!
    \brief          SimpleLinkWlanEventHandler

    This handler gets called whenever a WLAN event is reported
    by the host driver / NWP. Here user can implement he's own logic
    for any of these events. This handler is used by 'network_terminal'
    application to show case the following scenarios:

    1. Handling connection / Disconnection.
    2. Handling Addition of station / removal.
    3. RX filter match handler.
    4. P2P connection establishment.

    \param          pWlanEvent       -   pointer to Wlan event data.

    \return         void

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) sections 4.3.4, 4.4.5 and 4.5.5.

    \sa             cmdWlanConnectCallback, cmdEnableFilterCallback, cmdWlanDisconnectCallback,
                    cmdP2PModecallback.

*/
void SimpleLinkWlanEventHandler(SlWlanEvent_t *pWlanEvent)
{
    if(!pWlanEvent)
    {
        return;
    }

    switch(pWlanEvent->Id)
    {
        case SL_WLAN_EVENT_CONNECT:
        {
            SET_STATUS_BIT(app_CB.Status, STATUS_BIT_CONNECTION);

            /* Copy new connection SSID and BSSID to global parameters */
            memcpy(app_CB.CON_CB.ConnectionSSID, pWlanEvent->Data.Connect.SsidName, pWlanEvent->Data.Connect.SsidLen);
            memcpy(app_CB.CON_CB.ConnectionBSSID, pWlanEvent->Data.Connect.Bssid, SL_WLAN_BSSID_LENGTH);

            UART_PRINT("\n\r[WLAN EVENT] STA Connected to the AP: %s , "
                "BSSID: %x:%x:%x:%x:%x:%x\n\r",
                      app_CB.CON_CB.ConnectionSSID, app_CB.CON_CB.ConnectionBSSID[0],
                      app_CB.CON_CB.ConnectionBSSID[1],app_CB.CON_CB.ConnectionBSSID[2],
                      app_CB.CON_CB.ConnectionBSSID[3],app_CB.CON_CB.ConnectionBSSID[4],
                      app_CB.CON_CB.ConnectionBSSID[5]);

            sem_post(&app_CB.CON_CB.connectEventSyncObj);
        }
        break;

        case SL_WLAN_EVENT_DISCONNECT:
        {
            SlWlanEventDisconnect_t  *pEventData = NULL;

            CLR_STATUS_BIT(app_CB.Status, STATUS_BIT_CONNECTION);
            CLR_STATUS_BIT(app_CB.Status, STATUS_BIT_IP_ACQUIRED);
            CLR_STATUS_BIT(app_CB.Status, STATUS_BIT_IPV6_ACQUIRED);

            /* If ping operation is running, release it. */
            if(IS_PING_RUNNING(app_CB.Status))
            {
                sem_post(&app_CB.CON_CB.eventCompletedSyncObj);
                UART_PRINT("\n\rPing failed, since device is no longer connected.\n\r");
            }

            pEventData = &pWlanEvent->Data.Disconnect;

            /* If the user has initiated 'Disconnect' request,
              'reason_code' is SL_WLAN_DISCONNECT_USER_INITIATED */
            if(SL_WLAN_DISCONNECT_USER_INITIATED == pEventData->ReasonCode)
            {
                UART_PRINT("\n\r[WLAN EVENT] Device disconnected from the AP: %s,\n\r"
                "BSSID: %x:%x:%x:%x:%x:%x on application's request \n\r",
                  app_CB.CON_CB.ConnectionSSID, app_CB.CON_CB.ConnectionBSSID[0],
                  app_CB.CON_CB.ConnectionBSSID[1],app_CB.CON_CB.ConnectionBSSID[2],
                  app_CB.CON_CB.ConnectionBSSID[3],app_CB.CON_CB.ConnectionBSSID[4],
                  app_CB.CON_CB.ConnectionBSSID[5]);
            }
            else
            {
                UART_PRINT("\n\r[WLAN ERROR] Device disconnected from the AP: %s,\n\r"
                "BSSID: %x:%x:%x:%x:%x:%x\n\r",
                  app_CB.CON_CB.ConnectionSSID, app_CB.CON_CB.ConnectionBSSID[0],
                  app_CB.CON_CB.ConnectionBSSID[1],app_CB.CON_CB.ConnectionBSSID[2],
                  app_CB.CON_CB.ConnectionBSSID[3],app_CB.CON_CB.ConnectionBSSID[4],
                  app_CB.CON_CB.ConnectionBSSID[5]);
            }
            memset(&(app_CB.CON_CB.ConnectionSSID), 0x0, sizeof(app_CB.CON_CB.ConnectionSSID));
            memset(&(app_CB.CON_CB.ConnectionBSSID), 0x0, sizeof(app_CB.CON_CB.ConnectionBSSID));
        }
        break;

        case SL_WLAN_EVENT_PROVISIONING_STATUS:
        {
            /* Do nothing, this suppress provisioning event is because simplelink is configured to default state. */
        }
        break;

        case SL_WLAN_EVENT_STA_ADDED:
        {
            memcpy(&(app_CB.CON_CB.ConnectionBSSID), pWlanEvent->Data.STAAdded.Mac, SL_WLAN_BSSID_LENGTH);
            UART_PRINT("\n\r[WLAN EVENT] STA was added to AP: BSSID: %x:%x:%x:%x:%x:%x\n\r",
                    app_CB.CON_CB.ConnectionBSSID[0],app_CB.CON_CB.ConnectionBSSID[1],
                    app_CB.CON_CB.ConnectionBSSID[2],app_CB.CON_CB.ConnectionBSSID[3],
                    app_CB.CON_CB.ConnectionBSSID[4],app_CB.CON_CB.ConnectionBSSID[5]);
        }
        break;

        case SL_WLAN_EVENT_STA_REMOVED:
        {
            memcpy(&(app_CB.CON_CB.ConnectionBSSID), pWlanEvent->Data.STAAdded.Mac, SL_WLAN_BSSID_LENGTH);
            UART_PRINT("\n\r[WLAN EVENT] STA was removed from AP: BSSID: %x:%x:%x:%x:%x:%x\n\r",
                    app_CB.CON_CB.ConnectionBSSID[0],app_CB.CON_CB.ConnectionBSSID[1],
                    app_CB.CON_CB.ConnectionBSSID[2],app_CB.CON_CB.ConnectionBSSID[3],
                    app_CB.CON_CB.ConnectionBSSID[4],app_CB.CON_CB.ConnectionBSSID[5]);

            memset(&(app_CB.CON_CB.ConnectionBSSID), 0x0, sizeof(app_CB.CON_CB.ConnectionBSSID));
        }
        break;

        case SL_WLAN_EVENT_RXFILTER:
        {
            SlWlanEventRxFilterInfo_t  *triggred_filter = NULL;

            triggred_filter = &(pWlanEvent->Data.RxFilterInfo) ;

            UART_PRINT("\n\r[WLAN EVENT] Rx filter match triggered. Set filters in filter bitmap :0x%x.\n\r", triggred_filter->UserActionIdBitmap);

            /*
             *     User can write he's / her's rx filter match handler here.
             *     Be advised, you can use the 'triggred_filter' structure info to determine which filter
             *     has received a match. (Bit X is set if user action id X was passed to a filter that matched a packet.)
             */
        }
        break;

        case SL_WLAN_EVENT_P2P_DEVFOUND:
        {
            UART_PRINT("\n\r[WLAN EVENT] P2P Remote device found\n\r");
            sem_post(&(app_CB.P2P_CB.DeviceFound));
        }
        break;

        case SL_WLAN_EVENT_P2P_REQUEST:
        {
            UART_PRINT("\n\r[WLAN EVENT] P2P Negotiation request received\n\r");

            /* This information is needed to create connection*/
            memset(&(app_CB.P2P_CB.p2pPeerDeviceName), '\0', sizeof(app_CB.P2P_CB.p2pPeerDeviceName));
            memcpy(&app_CB.P2P_CB.p2pPeerDeviceName,
                    pWlanEvent->Data.P2PRequest.GoDeviceName,
                    pWlanEvent->Data.P2PRequest.GoDeviceNameLen);

            sem_post(&app_CB.P2P_CB.RcvNegReq);
        }
        break;

        case SL_WLAN_EVENT_P2P_CONNECT:
        {
            UART_PRINT("n\r[WLAN EVENT] P2P connection was successfully completed as CLIENT\n\r");
            UART_PRINT("n\rBSSID is %02x:%02x:%02x:%02x:%02x:%02x\n\r",
                                            pWlanEvent->Data.STAAdded.Mac[0],
                                            pWlanEvent->Data.STAAdded.Mac[1],
                                            pWlanEvent->Data.STAAdded.Mac[2],
                                            pWlanEvent->Data.STAAdded.Mac[3],
                                            pWlanEvent->Data.STAAdded.Mac[4],
                                            pWlanEvent->Data.STAAdded.Mac[5]);

            sem_post(&app_CB.P2P_CB.RcvConReq);
        }
        break;

        case SL_WLAN_EVENT_P2P_CLIENT_ADDED:
        {
            UART_PRINT("n\r[WLAN EVENT] P2P connection was successfully completed as GO\n\r");
            UART_PRINT("n\rBSSID is %02x:%02x:%02x:%02x:%02x:%02x\n\r",
                                            pWlanEvent->Data.P2PClientAdded.Mac[0],
                                            pWlanEvent->Data.P2PClientAdded.Mac[1],
                                            pWlanEvent->Data.P2PClientAdded.Mac[2],
                                            pWlanEvent->Data.P2PClientAdded.Mac[3],
                                            pWlanEvent->Data.P2PClientAdded.Mac[4],
                                            pWlanEvent->Data.P2PClientAdded.Mac[5]);

            sem_post(&app_CB.P2P_CB.RcvConReq);
        }
        break;

        case SL_WLAN_EVENT_P2P_DISCONNECT:
        {
            UART_PRINT("\n\r[WLAN EVENT] STA disconnected from device.\n\r");
            CLR_STATUS_BIT(app_CB.Status ,STATUS_BIT_CONNECTION);
        }
        break;

        default:
        {
            UART_PRINT("\n\r[WLAN EVENT] Unexpected event [0x%x]\n\r", pWlanEvent->Id);
        }
        break;
    }
    UART_PRINT(cmdPromptStr);
}

/*!
    \brief          SimpleLinkNetAppEventHandler

    This handler gets called whenever a Netapp event is reported
    by the host driver / NWP. Here user can implement he's own logic
    for any of these events. This handler is used by 'network_terminal'
    application to show case the following scenarios:

    1. Handling IPv4 / IPv6 IP address acquisition.
    2. Handling IPv4 / IPv6 IP address Dropping.

    \param          pNetAppEvent     -   pointer to Netapp event data.

    \return         void

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) section 5.7

*/
void SimpleLinkNetAppEventHandler(SlNetAppEvent_t *pNetAppEvent)
{
    if(!pNetAppEvent)
    {
        return;
    }

    switch(pNetAppEvent->Id)
    {
        case SL_NETAPP_EVENT_IPV4_ACQUIRED:
        {
            SlIpV4AcquiredAsync_t *pEventData = NULL;

            SET_STATUS_BIT(app_CB.Status, STATUS_BIT_IP_ACQUIRED);

            /* Ip Acquired Event Data */
            pEventData = &pNetAppEvent->Data.IpAcquiredV4;
            app_CB.CON_CB.IpAddr = pEventData->Ip ;

            /* Gateway IP address */
            app_CB.CON_CB.GatewayIP = pEventData->Gateway;

            UART_PRINT("\n\r[NETAPP EVENT] IP set to: IPv4=%d.%d.%d.%d , "
                    "Gateway=%d.%d.%d.%d\n\r",

                    SL_IPV4_BYTE(app_CB.CON_CB.IpAddr,3),
                    SL_IPV4_BYTE(app_CB.CON_CB.IpAddr,2),
                    SL_IPV4_BYTE(app_CB.CON_CB.IpAddr,1),
                    SL_IPV4_BYTE(app_CB.CON_CB.IpAddr,0),

                    SL_IPV4_BYTE(app_CB.CON_CB.GatewayIP,3),
                    SL_IPV4_BYTE(app_CB.CON_CB.GatewayIP,2),
                    SL_IPV4_BYTE(app_CB.CON_CB.GatewayIP,1),
                    SL_IPV4_BYTE(app_CB.CON_CB.GatewayIP,0));

            sem_post(&(app_CB.CON_CB.ip4acquireEventSyncObj));
        }
        break;

        case SL_NETAPP_EVENT_IPV6_ACQUIRED:
        {
            uint32_t i = 0;

            SET_STATUS_BIT(app_CB.Status, STATUS_BIT_IPV6_ACQUIRED);

            for(i = 0 ; i < 4 ; i++)
            {
                app_CB.CON_CB.Ipv6Addr[i] = pNetAppEvent->Data.IpAcquiredV6.Ip[i];
            }

            UART_PRINT("\n\r[NETAPP EVENT] IP Acquired: IPv6=");

            for(i = 0; i < 3 ; i++)
            {
                UART_PRINT("%04x:%04x:", ((app_CB.CON_CB.Ipv6Addr[i]>>16) & 0xffff), app_CB.CON_CB.Ipv6Addr[i] & 0xffff);
            }

            UART_PRINT("%04x:%04x", ((app_CB.CON_CB.Ipv6Addr[3]>>16) & 0xffff), app_CB.CON_CB.Ipv6Addr[3] & 0xffff);
            UART_PRINT(lineBreak);
            sem_post(&app_CB.CON_CB.ip6acquireEventSyncObj);
        }
        break;

        case SL_NETAPP_EVENT_DHCPV4_LEASED:
        {
            SET_STATUS_BIT(app_CB.Status, STATUS_BIT_IP_LEASED);
            SET_STATUS_BIT(app_CB.Status, STATUS_BIT_IP_ACQUIRED);

            app_CB.CON_CB.StaIp = pNetAppEvent->Data.IpLeased.IpAddress;
            UART_PRINT("\n\r[NETAPP EVENT] IP Leased to Client: IP=%d.%d.%d.%d \n\r",
                        SL_IPV4_BYTE(app_CB.CON_CB.StaIp ,3), SL_IPV4_BYTE(app_CB.CON_CB.StaIp ,2),
                        SL_IPV4_BYTE(app_CB.CON_CB.StaIp ,1), SL_IPV4_BYTE(app_CB.CON_CB.StaIp ,0));

            sem_post(&(app_CB.CON_CB.ip4acquireEventSyncObj));
        }
        break;

        case SL_NETAPP_EVENT_DHCPV4_RELEASED:
        {
            UART_PRINT("\n\r[NETAPP EVENT] IP is released.\n\r");
        }
        break;

        default:
        {
            UART_PRINT("\n\r[NETAPP EVENT] Unexpected event [0x%x] \n\r", pNetAppEvent->Id);
        }
        break;
    }
    UART_PRINT(cmdPromptStr);
}

/*!
    \brief          SimpleLinkHttpServerEventHandler

    This handler gets called whenever a HTTP event is reported
    by the NWP internal HTTP server.

    \param          pHttpEvent       -   pointer to http event data.

    \param          pHttpEvent       -   pointer to http response.

    \return         void

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) chapter 9.

*/
void SimpleLinkHttpServerEventHandler(SlNetAppHttpServerEvent_t *pHttpEvent,
                                      SlNetAppHttpServerResponse_t *pHttpResponse)
{
    /* Unused in this application */
}

/*!
    \brief          SimpleLinkGeneralEventHandler

    This handler gets called whenever a general error is reported
    by the NWP / Host driver. Since these errors are not fatal,
    application can handle them.

    \param          pDevEvent    -   pointer to device error event.

    \return         void

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) section 17.9.

*/
void SimpleLinkGeneralEventHandler(SlDeviceEvent_t *pDevEvent)
{
    if(!pDevEvent)
    {
        return;
    }
    /*
      Most of the general errors are not FATAL are are to be handled
      appropriately by the application
    */
    UART_PRINT("\n\r[GENERAL EVENT] - ID=[%d] Sender=[%d]\n\n",
               pDevEvent->Data.Error.Code,
               pDevEvent->Data.Error.Source);
}

/*!
    \brief          SimpleLinkSockEventHandler

    This handler gets called whenever a socket event is reported
    by the NWP / Host driver.

    \param          SlSockEvent_t    -   pointer to socket event data.

    \return         void

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) section 7.6.

*/
void SimpleLinkSockEventHandler(SlSockEvent_t *pSock)
{
    /* Unused in this application */
}

/*!
    \brief          SimpleLinkFatalErrorEventHandler

    This handler gets called whenever a socket event is reported
    by the NWP / Host driver. After this routine is called, the user's
    application must restart the device in order to recover.

    \param          slFatalErrorEvent    -   pointer to fatal error event.

    \return         void

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) section 17.9.

*/
void SimpleLinkFatalErrorEventHandler(SlDeviceFatal_t *slFatalErrorEvent)
{

    switch (slFatalErrorEvent->Id)
    {
        case SL_DEVICE_EVENT_FATAL_DEVICE_ABORT:
        {
            UART_PRINT("\n\r[ERROR] - FATAL ERROR: Abort NWP event detected: "
                        "AbortType=%d, AbortData=0x%x\n\r",
                        slFatalErrorEvent->Data.DeviceAssert.Code,
                        slFatalErrorEvent->Data.DeviceAssert.Value);
        }
        break;

        case SL_DEVICE_EVENT_FATAL_DRIVER_ABORT:
        {
            UART_PRINT("\n\r[ERROR] - FATAL ERROR: Driver Abort detected. \n\r");
        }
        break;

        case SL_DEVICE_EVENT_FATAL_NO_CMD_ACK:
        {
            UART_PRINT("\n\r[ERROR] - FATAL ERROR: No Cmd Ack detected "
                        "[cmd opcode = 0x%x] \n\r",
                                        slFatalErrorEvent->Data.NoCmdAck.Code);
        }
        break;

        case SL_DEVICE_EVENT_FATAL_SYNC_LOSS:
        {
            UART_PRINT("\n\r[ERROR] - FATAL ERROR: Sync loss detected n\r");
        }
        break;

        case SL_DEVICE_EVENT_FATAL_CMD_TIMEOUT:
        {
            UART_PRINT("\n\r[ERROR] - FATAL ERROR: Async event timeout detected "
                        "[event opcode =0x%x]  \n\r",
                                    slFatalErrorEvent->Data.CmdTimeout.Code);
        }
        break;

        default:
            UART_PRINT("\n\r[ERROR] - FATAL ERROR: Unspecified error detected \n\r");
        break;
    }
}

/*!
    \brief          SimpleLinkNetAppRequestEventHandler

    This handler gets called whenever a NetApp event is reported
    by the NWP / Host driver. User can write he's logic to handle
    the event here.

    \param          pNetAppRequest     -   Pointer to NetApp request structure.

    \param          pNetAppResponse    -   Pointer to NetApp request Response.

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) section 17.9.

    \return         void

*/
void SimpleLinkNetAppRequestEventHandler(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse)
{
    /* Unused in this application */
}

/*!
    \brief          SimpleLinkNetAppRequestMemFreeEventHandler

    This handler gets called whenever the NWP is done handling with
    the buffer used in a NetApp request. This allows the use of
    dynamic memory with these requests.

    \param          pNetAppRequest     -   Pointer to NetApp request structure.

    \param          pNetAppResponse    -   Pointer to NetApp request Response.

    \note           For more information, please refer to: user.h in the porting
                    folder of the host driver and the  CC3120/CC3220 NWP programmer's
                    guide (SWRU455) section 17.9.

    \return         void

*/
void SimpleLinkNetAppRequestMemFreeEventHandler(uint8_t *buffer)
{
    /* Unused in this application */
}

// End Event handlers

/* Callback function for interrupt*/
void Echo_Callback(uint_least8_t index)
{
    Echo_Echo = GPIO_read(Board_GPIO_Echo);
    if(Echo_Echo == 1)
    {
        GPIO_write(Board_GPIO_G, RGB_ON);
        Echo_Beg = Timer_getCount(sens_timer);
    } else
    {
        GPIO_write(Board_GPIO_G, RGB_OFF);
        Echo_End = Timer_getCount(sens_timer);
        DistTime = Echo_End - Echo_Beg;
        ans = GetDistance(DistTime);
        //UART_PRINT(" beg: %d end: %d diff: %d\n\r", Echo_Beg, Echo_End, DistTime);
    }
    if(ans >= 5)
    {
        // 5 seconds reached, turn LED blue and BT on
        GPIO_write(Board_GPIO_R, RGB_OFF);
        GPIO_write(Board_GPIO_G, RGB_OFF);
        GPIO_write(Board_GPIO_B, RGB_ON);
        GPIO_write(Board_GPIO_BT, 1);
    } else
    {
        GPIO_write(Board_GPIO_B, RGB_OFF);
        GPIO_write(Board_GPIO_BT, 0);
    }
}

void Test_Callback(uint_least8_t index)
{
    GPIO_toggle(Board_GPIO_TEST);
}

void *mainThread(void *arg0)
{

    /* Call driver init functions */
    GPIO_init();
    // I2C_init();
    // SDSPI_init();
    SPI_init();
    UART_init();
    Timer_init();
    // Watchdog_init();

    /* Initialize UART terminal for UART_PRINT() */
    InitTerm();

    /* Configure the LED pin */
    GPIO_setConfig(Board_GPIO_LED0, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);

    /* Configure Echo Pin for interrupts */

    GPIO_setConfig(Board_GPIO_Echo, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_BOTH_EDGES);

    /* Turn on user LED */
    GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_ON);

    GPIO_write(Board_GPIO_TEST, 0);
    GPIO_write(Board_GPIO_TRIG, 0);
    GPIO_write(Board_GPIO_R, RGB_OFF);
    GPIO_write(Board_GPIO_G, RGB_OFF);
    GPIO_write(Board_GPIO_B, RGB_OFF);
    GPIO_write(Board_GPIO_BT, 0);

    /* Configure timer params */
    Timer_Params_init(&sens_params);
    sens_params.period = 600000; /* .6s */
    //sens_params.period = 5000000; /* 5s */
    sens_params.periodUnits = Timer_PERIOD_US;
    sens_params.timerMode = Timer_CONTINUOUS_CALLBACK;
    /* runs this function every time the timer expires and then restarts timer */
    //sens_params.timerCallback = timerCallback;
    //sens_params.timerCallback = distCallback;
    //sens_params.timerCallback = RGBTest;
    //sens_params.timerCallback = BT_Test;
    //sens_params.timerCallback = StopWatch_Test;
    sens_params.timerCallback = TRIG_PULSE;

    /* Open timer to be started with Timer_Start() */
    sens_timer = Timer_open(Board_TIMER0, &sens_params);

    //inputTest();
    /*
    while(1)
    {
        exPulse(500000);
    }
    */

    /* callback and interrupt command */
    GPIO_setCallback(Board_GPIO_Echo, Echo_Callback);

    GPIO_enableInt(Board_GPIO_Echo);

    /* Starting timer and checking for errors */
    if (sens_timer == NULL) {
        /* Failed to initialized timer */
        UART_PRINT("Sensor Timer failed to initialize \n\r");
        while (1);
    }

    if (Timer_start(sens_timer) == Timer_STATUS_ERROR) {
        /* Failed to start timer */
        UART_PRINT("Fail to start sensor timer \n\r");
        while (1);
    }

    return (NULL);
}

void timerCallback(Timer_Handle myHandle)
{
    /* 10 usecond delay */
    //useconds_t time = 10;
    ZeroHour++;
    GPIO_toggle(Board_GPIO_TEST);
    /* Setting a 10 us pulse
    GPIO_write(Board_GPIO_TEST, 1);
    usleep(time);
    GPIO_write(Board_GPIO_TEST, 0);
     */

    /* Alternate Red LED every 1.2s */
    if(ZeroHour >= 2)
    {
        GPIO_toggle(Board_GPIO_LED0);
        ZeroHour = 0;
    }
}


void distCallback(Timer_Handle myHandle)
{
    // 10 us pulse
    setPulse(10);
    // Wait for Echo to go high
    while(break_it == 0)
    {
        Echo_Echo = GPIO_read(Board_GPIO_Echo);

        if(Echo_Echo == 0)
        {
           if(Echo_1 == 0)
           {
               // No Echo received yet
               DoNothing();
           } else
           {
               // Echo signal dropped, calculate the distance
               GPIO_write(Board_GPIO_TEST, 0);
               Echo_End = Timer_getCount(sens_timer);
               DistTime = Echo_End - Echo_Beg;
               UART_PRINT(" %d \n\r", DistTime);
               ans = GetDistance(DistTime);
               if(ans >= 5)
               {
                   // 5 seconds reached, turn LED blue and BT on
                   GPIO_write(Board_GPIO_R, RGB_OFF);
                   GPIO_write(Board_GPIO_G, RGB_OFF);
                   GPIO_write(Board_GPIO_B, RGB_ON);
                   GPIO_write(Board_GPIO_BT, 1);
               } else
               {
                   GPIO_write(Board_GPIO_B, RGB_OFF);
                   GPIO_write(Board_GPIO_BT, 0);
               }
               break_it = 1;
               break;
           }
        } else
        {
            if(Echo_1 == 0)
            {
                // Started receiving echo signal, start timer
                Echo_Beg = Timer_getCount(sens_timer);
                GPIO_write(Board_GPIO_TEST, 1);
            } else
            {
                // Still receiving echo signal
                DoNothing();
            }
        }

        Echo_1 = Echo_Echo;
    }

    break_it = 0;
}

void BT_Test(Timer_Handle myHandle)
{
    ZeroHour++;
    if(ZeroHour >= 5)
    {
        GPIO_toggle(Board_GPIO_BT);
        ZeroHour = 0;
    }
}

void StopWatch_Test(Timer_Handle myHandle)
{
    Echo_Beg = Timer_getCount(sens_timer);
    exPulse(5000);
    Echo_End = Timer_getCount(sens_timer);
    DistTime = Echo_End - Echo_Beg;
    UART_PRINT(" Beg: %d End: %d Diff: %d \n\r", Echo_Beg, Echo_End, DistTime);
}

void TRIG_PULSE(Timer_Handle myHandle)
{
    // Send a 10 us pulse to trig pin
    setPulse(10);
}

void exPulse(useconds_t time)
{
    GPIO_write(Board_GPIO_TEST, 1);
    usleep(time);
    GPIO_write(Board_GPIO_TEST, 0);
    usleep(time);
    return;
}

void setPulse(useconds_t time)
{
    GPIO_write(Board_GPIO_TRIG, 1);
    usleep(time);
    GPIO_write(Board_GPIO_TRIG, 0);
    return;
}

void DoNothing(void)
{
    return;
}

int GetDistance(uint32_t distime)
{
    double time_s = distime / 1000000.0;
    double dist = 17150 * time_s;
    UART_PRINT(" time: %f dist: %f \n\r", time_s, dist);
    if(dist < THRESHOLD)
    {
        GPIO_write(Board_GPIO_R, RGB_ON);
        GPIO_write(Board_GPIO_G, RGB_OFF);
        BTcount++;
    } else
    {
        GPIO_write(Board_GPIO_R, RGB_OFF);
        GPIO_write(Board_GPIO_G, RGB_ON);
        GPIO_write(Board_GPIO_B, RGB_OFF);
        BTcount = 0;
    }
    return BTcount;
}

void inputTest(Timer_Handle myHandle)
{
    // Testing Input for Input pins
    uint_fast8_t LED_ON;

    while(1)
    {
        // P53
        //LED_ON = GPIO_read(Board_GPIO_INTEST);

        // Sw3
        LED_ON = GPIO_read(Board_GPIO_BUTTON0);

        if(LED_ON == 1)
        {
            GPIO_write(Board_GPIO_TEST, 1);
        } else
        {
            GPIO_write(Board_GPIO_TEST, 0);
        }
    }
}

void RGBTest(Timer_Handle myHandle)
{
    if(i == 0)
    {
        GPIO_write(Board_GPIO_R, RGB_ON);
        GPIO_write(Board_GPIO_G, RGB_OFF);
        GPIO_write(Board_GPIO_B, RGB_OFF);
    } else if(i == 1)
    {
        GPIO_write(Board_GPIO_R, RGB_OFF);
        GPIO_write(Board_GPIO_G, RGB_ON);
        GPIO_write(Board_GPIO_B, RGB_OFF);
    } else
    {
        GPIO_write(Board_GPIO_R, RGB_OFF);
        GPIO_write(Board_GPIO_G, RGB_OFF);
        GPIO_write(Board_GPIO_B, RGB_ON);
    }
    i++;
    if(i >= 3)
    {
        i = 0;
    }
}
